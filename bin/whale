#!/usr/bin/env ruby
# whale

# 20080520
WHALE_VERSION = '0.4.6'

# Description: Sometimes when they go fishing, they get a whale and it sinks their boat.  

# History: 
# 1. I took #read_words_file from difflist.  
# 2. I took a bit of RandomMethod for #random_word.   

# Discussion: 
# 1. As yesterday's site is down I've selected my next victim.  It is a PayPal phishing site and they've got some Javascript which  checks that the username conforms to being an acceptable email address.  Then I noticed that the form is not dependent on Javascript and so it could be gotton around by simply ignoring Javascript as Whale does.  However, since one of the goals is to make the real user data indistinguishable from the fake, it seems as if it is a better idea to make the data input from Whale look like the most likely set of real user data.  
# 2. The changes from 0.4.2 were precipitated by a site which had no form name.  Although much of the changes were in addition to this particular purpose.  

# Changes since 0.3: 
# 1. I've added the option to select a user agent.  
# 2. I've also added the option to be able to follow meta-refresh links.  Neat!  I can test it on that PayPal phishing site which necessitated, or at least had recommended, having email addresses, since it used a meta-refresh.  
# 3. I've removed the debugging stuff.  
# 4. There was an error if there was no meta refresh of course!  So now it doesn't attempt to access the match data array unless there's something in it.  
# 3
# 5. Somtimes a form won't have a name, so I need to just grab the first one or a subsequent one if need be...  
# 6. Added a hash to pass in options to Whale.initialize.  
# 4
# 7. Added in option parsing via Options and Whale.parse_options.  
# 8. Enabled the use of this in the self-run block.  
# 5
# 9. Created a whole bunch of methods to abstract the process of determining the page, the form, the fields.  
# 10. Gave @words a method.  
# 11. Fixed the remnants of what I copied from express.  
# 12. Made more extensive use of accessors/readers.  
# 13. Overall much lispier.  
# 6
# 14. I can now set which form to be used by a zero-based index via form_number.  
# 15. Forgot to do command line parsing of the URL!  
# 16. Defaults for Whale#initialize.  
# 17. require 'optparse'!  
# 18. A few option parsing and variable setting tidyups.  
# 19. Fixed a problem with the mechanize instance not being found, so it is now an instanc variable.  

# Todo: 
# 1. Command line options library needed really, since fixed order options is a bit blerrr.  Done as of 0.4.4, but really working as of 0.4.5.  
# 2. Be able to set the username and password fields by number.  

require 'rubygems'
require 'mechanize'

require 'optparse'
require 'pp'

$debug = false

TLD = %w{com net org edu int mil gov arpa biz aero name coop info pro museum}
TLD_SIZE = 15

class Options
  
  class << self
    attr_accessor :form_name, :form_number, :username_field_name, :password_field_name, :verbose, :username_is_email_address, :user_agent
  end
  
end # class Options

class Whale
  
  attr_accessor :url
  attr_accessor :form_name, :form_number, :username_field_name, :password_field_name
  attr_accessor :verbose, :username_is_email_address, :user_agent
  attr_reader :words, :words_size
  
  def initialize(url = nil, options = {})
    @url = url
    @form_name = options[:form_name] || nil
    @username_field_name = options[:username_fieldname] || nil
    @password_field_name = options[:password_field_name] || nil
    @verbose = options[:verbose] || false
    @username_is_email_address = options[:username_is_email_address] || false
    @user_agent = options[:user_agent] || 'Windows IE 6'
    @words = read_words_file('/usr/share/dict/words')
    @words_size = @words.size # It is more efficient for this to be called once here.  
  end
  
  def parse
    parse_url
    parse_options
  end
  
  def parse_url
    if (ARGV[0] !~ /^-/ && ARGV[0])
      @url = ARGV[0]
    else
      raise RuntimeError, 'No URL provided.'
    end
  end
  
  def parse_options
    op = OptionParser.new do |opts|
      opts.banner = 'Usage: whale <url> and any of the following options...'
      opts.on('-f', '--form', '--form-name', '--form_name <form_name>', "If left empty, the first form on the page will be used.") do |opt|
        Options.form_name = opt
      end
      opts.on('-n', '--form-number', '--form_number <form_number>', "This will set the number of the form in order of appearance on the page.  Use zero-based indexing...") do |opt|
        Options.form_number = opt
      end
      opts.on('-u', '--username-field-name', '--username_field_name <username_field_name>', '') do |opt|
        Options.username_field_name = opt
      end
      opts.on('-p', '--password-field-name', '--password_field_name <password_field_name>', '') do |opt|
        Options.password_field_name = opt
      end
      opts.on('-V', '--verbose', 'Outputs each submission as it goes.') do |opt|
        Options.verbose = opt
      end
      opts.on('-e', '--username-is-email-address', '--username_is_email_address', 'Automatically generate a username which is in the form of an email address.') do |opt|
        Options.username_is_email_address = opt
      end
      opts.on('-a', '--user-agent', '--user_agent <user_agent>', 'What webclient I should pretend to be.') do |opt|
        Options.user_agent = opt
      end
      opts.on('-?', '--help', 'Displays this information.') do
        puts opts
        exit
      end
      opts.on('-v', '--version', 'Displays version information.') do
        puts "whale #{WHALE_VERSION}"
        exit
      end
    end
    op.parse!
    %w{form_name form_number username_field_name password_field_name verbose username_is_email_address user_agent}.each{|o| new_value = Options.send(o); self.send("#{o}=", new_value) if new_value}
  end # def parse_options
  
  def counter_phish
    start_time = Time.now
    puts "Whale session begun #{start_time}."
    submission_count = 0
    @m = WWW::Mechanize.new
    @m.user_agent_alias = user_agent
    begin
      loop do
        set_username_field
        set_password_field
        @m.submit(form)
        pp @m.submit(form) if $debug
        submission_count += 1
        puts "#{submission_count} #{username}:#{password}" if verbose
      end
    ensure
      finish_time = Time.now
      time_delta_in_minutes = (finish_time - start_time) / 60
      submissions_per_minute = submission_count / time_delta_in_minutes
      puts "Whale session terminated #{finish_time} with #{submission_count} counter-phishes served in #{time_delta_in_minutes} minutes for an average of #{submissions_per_minute} submissions per minute."
    end
  end # def counter_phish
  
  private
  
  def read_words_file(filename)
    a = []
    File.open(filename, 'r').each {|line| a << line.chomp }
    a
  end
  
  def random_word
    words[rand(words_size)]
  end
  
  def random_TLD
    TLD[rand(TLD_SIZE)]
  end
  
  def page # This is a big timesaver.  I think I don't need to keep grabbing the page everytime.  
    @page ||= (
      _page = @m.get(@url)
      md = _page.body.match(/meta.*?Refresh.*?url=(.*?)"/i)
      if md
        puts 'meta_refresh_url found' if $debug
        _page = @m.get(md[1])
        pp _page if $debug
      end
      pp _page if $debug
      _page
    )
  end
  
  def form # Similarly to #page.  I don't think I need to grab it everytime either.  
    @form ||= (
      if form_name
        page.form(form_name)
      elsif form_number
        page.forms[form_number.to_i]
      else
        page.forms[0]
      end
    )
  end
  
  def username
    if username_is_email_address
      "#{random_word}@#{random_word}.#{random_TLD}"
    else
      random_word
    end
  end
  
  def password
    random_word
  end
  
  def set_username_field
    if username_field_name
      form[username_field_name] = username
    else
      form.fields[0] = username
    end
  end
  
  def set_password_field
    if password_field_name
      form[password_field_name] = password
    else
      form.fields[1] = password
    end
  end
  
end

if __FILE__ == $0
  w = Whale.new
  w.parse
  w.counter_phish
end
